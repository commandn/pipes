package main

import (
	"context"
	"errors"
	"io"
	"log/slog"
	"net/http"
	"os"
	"reflect"

	"github.com/foobarbazmeow/pipes"
)

const (
	googleHandlerId = 0
	amazonHandlerId = 1
	openaiHandlerId = 2
)

var handlers = []int{
	googleHandlerId,
	amazonHandlerId,
	openaiHandlerId,
}

func fetchHandler(url string) pipes.Handler[pipes.Store] {
	return func(context.Context, pipes.Store) (any, error) {
		response, err := http.Get(url)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		bytes, err := io.ReadAll(response.Body)
		if err != nil {
			return nil, err
		}
		return string(bytes), nil
	}
}

func main() {
	store := pipes.NewStore()
	runner := pipes.NewRunner[pipes.Store]()
	registrator := pipes.NewRegistrator(store, runner)

	// step #1: configure the pipeline
	err := errors.Join(
		registrator(googleHandlerId, fetchHandler("https://google.com")),
		registrator(amazonHandlerId, fetchHandler("https://amazon.com")),
		registrator(openaiHandlerId, fetchHandler("https://openai.com")),
	)
	if err != nil {
		slog.Error("fail to register handler", "err", err)
		os.Exit(1)
	}

	ctx := context.Background()

	// step #2: run the pipeline
	if err = runner.Run(ctx, store); err != nil {
		slog.Error("fail to run pipeline", "err", err)
		os.Exit(1)
	}

	// step #3: read the state of the pipeline generated by the handlers
	for _, handlerId := range handlers {
		data, err := store.Read(ctx, handlerId)
		slog.Info(
			"handler result",
			"handler-id", handlerId,
			"data-type", reflect.TypeOf(data),
			"err", err,
		)
	}

	// step #3.1: a type-safe way to read the state of the pipeline
	data, err := pipes.Read[string](ctx, store, googleHandlerId)
	slog.Info(
		"typed data from google handler",
		"content-length", len(data),
		"err", err,
	)
}
